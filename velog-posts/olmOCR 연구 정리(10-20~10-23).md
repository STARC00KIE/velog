<h2 id="목표">목표</h2>
<ul>
<li>파이프라인 단계별로 Input -&gt; Output 자세하게 조사하기</li>
<li>Poppler가 어떤 기능을 하는지 조사하기</li>
<li>PageResponse가 어디에 호출되고 사용되는지 조사하기</li>
</ul>
<hr />
<h2 id="파이프라인-개요">파이프라인 개요</h2>
<ul>
<li>수많은 PDF 파일을 입력받아, 각각의 페이지를 개별적으로 AI 모델을 이용하여 추론을 진행하고 결과 종합<pre><code class="language-YAML">[시작] -&gt; [1. 진입점] -&gt; [2. 작업 분배] -&gt; [3. 개별 PDF 파일 처리] -&gt; [4. 페이지 단위 처리] -&gt; [5. AI 요청 생성] -&gt; [6. 네트워크 통신] -&gt; [AI 서버]
^                                                                                                                                    |
|____________________________________________________________________________________________________________________________________| (응답)</code></pre>
</li>
</ul>
<hr />
<h2 id="1-진입점entry-point">1. 진입점(Entry Point)</h2>
<h3 id="사용-함수">사용 함수</h3>
<ul>
<li><code>def main()</code></li>
</ul>
<h3 id="설명">설명</h3>
<ul>
<li>파이프라인 전체의 시작점</li>
</ul>
<h3 id="세부-역할">세부 역할</h3>
<ol>
<li><p>설정 및 인자 파싱</p>
</li>
<li><p>환경 설정: Beaker 클러스터 여부 확인, AWS/GCS 인증 정보 설정, 클라이언트 초기화</p>
</li>
<li><p><code>work_queue</code> 준비(앞으로 처리해야 할 작업들의 목록을 담아두는 저장소)</p>
</li>
<li><p>실행 모드 결정(통계 분석 모드, Beaker 작업 제출 모드)</p>
</li>
<li><p>추론 환경 준비 및 vllm 서버 시작</p>
</li>
<li><p><strong>worker 실행 및 관리</strong></p>
<pre><code class="language-python"> &quot;&quot;&quot;
 work_queue: 앞으로 처리해야 할 작업들의 목록을 담아두는 저장소
 semaphore: 동시에 접근할 수 있는 작업 수(1개)
    worker_id: worker에게 부여되는 식별자
 task: worker의 실행 상태를 제어하고 조회하는 데 사용되는 객체
 &quot;&quot;&quot;
 metrics_task = asyncio.create_task(metrics_reporter(work_queue))

 # 큐를 동시에 처리하기 위해 worker_tasks 들을 생성함
 worker_tasks = []
 for i in range(args.workers):
     task = asyncio.create_task(worker(args, work_queue, semaphore, worker_id=i))
     worker_tasks.append(task)

 # 모든 task가 끝날 때까지 대기
 await asyncio.gather(*worker_tasks)</code></pre>
</li>
<li><p>정리 및 최종 결과 출력</p>
</li>
</ol>
<hr />
<h2 id="2-작업-분배">2. 작업 분배</h2>
<h3 id="사용-함수-1">사용 함수</h3>
<ul>
<li><code>def worker()</code></li>
</ul>
<h3 id="설명-1">설명</h3>
<ul>
<li>작업 분배 및 실행</li>
</ul>
<h3 id="세부-역할-1">세부 역할</h3>
<ol>
<li><p>작업 권한 획득 및 할당</p>
</li>
<li><p><strong>PDF 동시에 처리</strong></p>
<pre><code class="language-python">     &quot;&quot;&quot;
     work_item.work_paths: 치리해야 할 PDF 파일들의 경로가 담겨져 있는 리스트
     pdf: 처리할 단일 PDF 파일의 경로를 나타내는 문자열
     dolma_tasks: 한 worker가 처리해야 할 모든 PDF 파일에 대한 process_pdf 태스크 객체들을 모아놓은 리스트
     tg.create_task()가 호출될 때 process_pdf(...) 태스크 생성 및 TaskGroup에 등록되어 즉시 실행 시작
     &quot;&quot;&quot;
     try:
         async with asyncio.TaskGroup() as tg:
             dolma_tasks = [tg.create_task(process_pdf(args, worker_id, pdf)) for pdf in work_item.work_paths]
             logger.info(f&quot;Created all tasks for {work_item.hash}&quot;)

         logger.info(f&quot;Finished TaskGroup for worker on {work_item.hash}&quot;)</code></pre>
</li>
<li><p>결과 집계 및 오류 처리</p>
</li>
<li><p>최종 결과물 생성 및 저장</p>
</li>
<li><p>마크다운 파일 생성</p>
</li>
<li><p>작업 완료 보고 및 메트릭 업데이트</p>
</li>
<li><p>예외 처리 및 세마포어 해제</p>
</li>
</ol>
<hr />
<h2 id="3-개별-pdf-파일-처리">3. 개별 PDF 파일 처리</h2>
<h3 id="사용-함수-2">사용 함수</h3>
<ul>
<li><code>def process_pdf()</code></li>
</ul>
<h3 id="설명-2">설명</h3>
<ul>
<li>단일 PDF 파일 하나를 처음부터 끝까지 처리하는 함수</li>
</ul>
<h3 id="세부-역할-2">세부 역할</h3>
<ol>
<li><p>PDF 파일 다운로드 및 임시 파일 생성</p>
</li>
<li><p>PDF 유효성 검사 및 필터링</p>
<pre><code class="language-python"> &quot;&quot;&quot;
 reader: PDF 파일을 열고 내부 정보에 접근할 수 있게 해주는 객체
 num_pages: `reader`를 통해 알아낸 PDF 파일의 전체 페이지 수, 작업량을 결정
    &quot;&quot;&quot;
 try:
     try:
         reader = PdfReader(tf.name) # pypdf의 PdfReader 클래스 사용
         num_pages = reader.get_num_pages()
     except:
         logger.exception(f&quot;Could not count number of pages for {pdf_orig_path}, aborting document&quot;)
         return None</code></pre>
</li>
<li><p><strong>페이지 단위 동시 처리</strong></p>
<pre><code class="language-python">     &quot;&quot;&quot;
     page_tasks: 실행 중, 또는 완료된 각 페이지 처리 작업(tast) 자체를 가리키는 객체들의 리스트
     page_results: 모든 페이지 작업이 성공적으로 끝난 후의 반환값들을 모아놓은 리스트
     &quot;&quot;&quot;
     page_tasks = []
     page_results = []

     try:
         async with asyncio.TaskGroup() as tg:
             for page_num in range(1, num_pages + 1):
                 task = tg.create_task(process_page(args, worker_id, pdf_orig_path, tf.name, page_num))
                 page_tasks.append(task)

         # PDF 파일의 전체 저리 결과를 저장
         page_results = [task.result() for task in page_tasks]</code></pre>
</li>
<li><p>처리한 결과 검증 및 취합</p>
<pre><code class="language-python">&quot;&quot;&quot;
이 부분 따로 추가해야 함
&quot;&quot;&quot;
def build_dolma_document(pdf_orig_path, page_results) </code></pre>
</li>
<li><p>치명적 오류 처리 및 정리</p>
</li>
</ol>
<hr />
<h2 id="4-페이지-단위-처리">4. 페이지 단위 처리</h2>
<h3 id="사용-함수-3">사용 함수</h3>
<ul>
<li><code>def process_page()</code></li>
</ul>
<h3 id="설명-3">설명</h3>
<ul>
<li>PDF의 단일 페이지 하나를 AI 모델로 처리하는 모든 과정을 관리</li>
</ul>
<h3 id="세부-역할-3">세부 역할</h3>
<ol>
<li><p>초기 변수 설정 및 엔드포인트 URL 설정</p>
<pre><code class="language-python"> &quot;&quot;&quot;
 주요 변수

 COMPLETION_URL: API 엔드포인트 URL
 MODEL_MAX_CONTEXT: 사용하는 AI 모델이 처리할 수 있는 최대 context 길이(토큰 수), 16384
 TEMPERATURE_BY_ATTEMPT: 재시도 횟수에 따라 사용할 temperature 값들을 미리 정의해 놓은 리스트, [0.1, 0.1, ~ , 0.9, 1.0]
 cumulative_rotation: 페이지 이미지의 누적 회전 각도를 추적하는 변수 
 &quot;&quot;&quot;</code></pre>
</li>
<li><p>최대 재시도 횟수에 도달할 때까지 페이지 처리 반복</p>
</li>
<li><p><strong>동적 요청 생성 및 API 호출</strong></p>
<pre><code class="language-python">     &quot;&quot;&quot;
     query: AI 모델 서버에 보낼 요청을 담고 있는 파이썬 딕셔너리(build_page_query 함수를 통해 생성)
     args.target_longest_image_dim: PDF 페이지를 이미지로 랜더링 할 때, 생성될 이미지의 가장 긴 변의 목표 픽셀 크기를 지정하는 변수 값
                                      AI 모델에 이미지를 입력하기 전 이미지 해상도 표준화 역할
     &quot;&quot;&quot;
     query = await build_page_query(
         pdf_local_path,
         page_num,
         args.target_longest_image_dim,
         image_rotation=cumulative_rotation,
         model_name=model_name,
     )
     # Change temperature as number of attempts increases to overcome repetition issues at expense of quality
     query[&quot;temperature&quot;] = TEMPERATURE_BY_ATTEMPT[lookup_attempt]

     # 모델의 답변 형식 강제
     if args.guided_decoding:
         query[&quot;guided_regex&quot;] = (
             r&quot;---\nprimary_language: (?:[a-z]{2}|null)\nis_rotation_valid: (?:True|False|true|false)\nrotation_correction: (?:0|90|180|270)\nis_table: (?:True|False|true|false)\nis_diagram: (?:True|False|true|false)\n(?:---|---\n[\s\S]+)&quot;
         )</code></pre>
</li>
<li><p><strong>응답 처리 및 검증</strong></p>
<pre><code class="language-python">     &quot;&quot;&quot;
     api_key: 외부 서버에서 실행했을 때 필요한 API 키
     apost 함수릁 통해 서버와 통신(추론) 진행
     status_code: HTTPS 응답 상태 코드, 200일 때만 정상
     response_body: 서버가 응답(response)한 내용, 추론 결과
       &quot;&quot;&quot;   
     try:
         # 사용자가 외부 서버(--server)를 사용하도록 지정했고, API 키(--api_key)도 함께 제공했을 때
         if args.server and hasattr(args, &quot;api_key&quot;):
             api_key = args.api_key
         else:
             api_key = None
         # api에게 추론을 요청하는 코드, status_code 200이면 요청/응답 정상 처리되는 것을 알 수 있음
         status_code, response_body = await apost(COMPLETION_URL, json_data=query, api_key=api_key)</code></pre>
<pre><code class="language-python">         &quot;&quot;&quot;
         status_code가 200(정상)일 때 실행되는 부분
         FrontMatterParser: Front Matter 형식의 텍스트를 파싱하기 위해 만들어진 클래스
         &quot;&quot;&quot;
         # 모델 응답 에서 Front Matter(메타데이터)와 텍스트 본문 분리
         parser = FrontMatterParser(front_matter_class=PageResponse)
         front_matter, text = parser._extract_front_matter_and_text(model_response_markdown)
         page_response = parser._parse_front_matter(front_matter, text)</code></pre>
</li>
<li><p>예외 처리</p>
</li>
<li><p>루프를 종료하고 난 후 모든 재시도가 실패했을 때 anchor 정보를 활용하여 처리</p>
</li>
</ol>
<hr />
<h2 id="5-ai-요청-생성">5. AI 요청 생성</h2>
<h3 id="사용-함수-4">사용 함수</h3>
<ul>
<li><code>def build_page_query()</code></li>
</ul>
<h3 id="설명-4">설명</h3>
<ul>
<li>PDF의 특정 페이지를 받아 이미지로 변환하고, 필요한 회전을 적용한 뒤 AI 모델 서버가 이해할 수 있는 표준 형식의 <code>JSON</code> 데이터를 만들어 반환함</li>
</ul>
<h3 id="세부-역할-4">세부 역할</h3>
<ul>
<li>PDF 페이지 랜더링 및 동시성 제어</li>
<li>이미지 회전(필요 시)</li>
<li>최종 API 요청 본문(멀티모달 입력 형식) 생성</li>
</ul>
<hr />
<h2 id="6-low-level-네트워크-통신">6. Low-level 네트워크 통신</h2>
<h3 id="사용-함수-5">사용 함수</h3>
<ul>
<li><code>def apost()</code> (&quot;Async Post&quot;)</li>
</ul>
<h3 id="설명-5">설명</h3>
<ul>
<li>파이프라인의 낮은 계층으로, 생성된 요청 데이터를 이용하여 네트워크를 통해 서버와 통신하는 역할</li>
</ul>
<h3 id="세부-역할-5">세부 역할</h3>
<ol>
<li>주소 분석 및 연결 준비</li>
<li>서버와 연결</li>
<li>HTTP 요청 메시지 쟁성</li>
<li>요정 전송</li>
<li>응답 수신 및 분석</li>
<li>결과 반환</li>
<li>예외 처리 및 자원 정리</li>
</ol>